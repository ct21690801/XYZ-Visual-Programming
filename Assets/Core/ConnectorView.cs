// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Linq;
using System.Collections.Generic;
using UnityEngine.EventSystems;
using System.ComponentModel;

public class ConnectorView:BaseView<ConnectorModel>
{

       
		public PortModel StartPort{ get; set; }
		public PortModel EndPort{ get; set; }
		public List<GameObject> TemporaryGeometry;
		protected GameObject geometryToRepeat;

		public virtual void init (Vector3 startpoint, Vector3 endpoint)
		{
			if (!started)
			{
				Start();
			}
				redraw (startpoint, endpoint,geometryToRepeat);
                TemporaryGeometry.Select(x => x.transform.parent = this.gameObject.transform);
				
		}

		protected override void Start()
		{
			NormalScale = new Vector3(.2f, .2f, .2f);
			HoverScale = new Vector3(.2f, .2f, .2f);
			base.Start();
			geometryToRepeat = Model.UIsubgeo;
			
		}

        protected override void OnDestroy()
        {
            base.OnDestroy();
                if (TemporaryGeometry != null)
                {
                    TemporaryGeometry.ForEach(x => UnityEngine.GameObject.DestroyImmediate(x));
                }
                if (Model != null)
                {
                    Model.PStart.PropertyChanged -= HandlePortChanges;
                    Model.PEnd.PropertyChanged -= HandlePortChanges;
                }
            
        }

		
		
        public override void OnPointerUp(PointerEventData pointerdata)
        {
            
        }

        public override void OnPointerClick(PointerEventData pointerdata)
        {
          
        }


        public override void OnDrag(PointerEventData pointerdata)
        {
            
        }
        public virtual List<GameObject> redraw()
        {
            var geo = redraw(StartPort.gameObject.transform.position, EndPort.gameObject.transform.position,geometryToRepeat);
            if (UI != null)
            {
                geo.ForEach(x => x.transform.parent = UI.transform);
            }
            return geo;
        }
		public virtual List<GameObject> redraw(GameObject explicitgeoToRepeat)
		{
			var geo = redraw(StartPort.gameObject.transform.position, EndPort.gameObject.transform.position, explicitgeoToRepeat);
			if (UI != null)
			{
				geo.ForEach(x => x.transform.parent = UI.transform);
			}
			return geo;
		}

		public List<GameObject> redraw (Vector3 startPoint, Vector3 endpoint,GameObject geoToRepeat)
		{
				if (TemporaryGeometry != null) {
						TemporaryGeometry.ForEach (x => UnityEngine.GameObject.DestroyImmediate (x));
				}
		var dist = Mathf.CeilToInt( Vector3.Distance(startPoint,endpoint));
				var range = Enumerable.Range (0, dist*5).Select (i => i / (dist*5F)).ToList ();
				//var points = range.Select (x => Vector3.Slerp (startPoint, endpoint, x)).ToList ();
		//var ctrlpoints = generateBezierControlPoints(startPoint,endpoint);

		//var points1 = range.Select(x=>evaluateBezierAtParameter(ctrlpoints[0],ctrlpoints[2],ctrlpoints[1],x)).ToList();
		//var points2 = range.Select(x=>evaluateBezierAtParameter(ctrlpoints[3],ctrlpoints[5],ctrlpoints[4],x)).ToList();

		//var points3 = points1.Concat(points2).ToList();

		var points1 = generateHermitePointsandTangents(startPoint,endpoint);
		var points3 = range.Select(x=> evaluateCubicHermiteAtParamter(points1[0],points1[2],points1[1],points1[3],x)).ToList();

		var geos = points3.Select (x => {
					var y = GameObject.Instantiate(geoToRepeat) as GameObject;
						GameObject.DestroyImmediate (y.GetComponent<Collider>());
						y.transform.position = x;
						y.transform.localScale = NormalScale;
						return y;}).ToList ();
		
				TemporaryGeometry = geos;
				return geos;
		}
		

	private List<Vector3> generateHermitePointsandTangents(Vector3 start, Vector3 end)
	{

		var tan1 = new Vector3(0,0,Math.Abs((start - end).z*2));
		var tan2 = new Vector3(0,0,Math.Abs((end - start).z*2));

		var output = new List<Vector3>();
		output.Add(start);
		output.Add(tan1);
		output.Add(end);
		output.Add(tan2);
		return output;

	}

	private List<Vector3> generateBezierControlPoints(Vector3 start, Vector3 end)
	{
		//first quadratic curve points
		var start1 = start;
		var end1 = ((end-start)/2)+start;
		//var perp = Vector3.Cross(new Vector3(0,(end1-start1).y,0),end-start);
		var control1 = end1 + new Vector3(0,(end1-start1).y*2,0);


		var start2 = end1;
		var end2 = end;
		//var perp2 = Vector3.Cross(new Vector3(0,(end2-end1).y,0),end-start);
		var control2 = end1 - new Vector3(0,(end2-end1).y*2,0);

		var output = new List<Vector3>();
		output.Add(start1);
		output.Add(end1);
		output.Add(control1);
		output.Add(start2);
		output.Add(end2);
		output.Add(control2);
		return output;
	}

		private Vector3 evaluateBezierAtParameter(Vector3 p0, Vector3 p1, Vector3 p2, float parameter)
	{
		 return (1.0f - parameter) * (1.0f - parameter) * p0
			+ 2.0f * (1.0f - parameter) * parameter * p1
				+parameter * parameter * p2;

	}

	private Vector3 evaluateCubicHermiteAtParamter(Vector3 p0, Vector3 p1, Vector3 tan1, Vector3 tan2, float parameter)
	{
		return   ((((2*(Mathf.Pow(parameter,3))) - (3*Mathf.Pow(parameter,2)) + 1 ))*p0) + 
			(((parameter*parameter*parameter) - (2*(parameter*parameter)) + parameter ) *tan1) +
				(((-2*(Mathf.Pow(parameter,3))) + (3*Mathf.Pow(parameter,2))) *p1) + 
				((parameter*parameter*parameter) - ((parameter*parameter)))*tan2;
	}

		public void HandlePortChanges (object sender, PropertyChangedEventArgs args)
		{
				//only redraw if we're forwarding a location change
		if (args.PropertyName == "OwnerPropertiesLocation") {
			redraw ();
		}
		}


}